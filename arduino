// ========================================
// SISTEMA DE MONITOREO DE DEFORMACIONES
// 4 Transductores Potenciométricos Lineales 2kΩ
// Precisión: ±0.005%
// ========================================

// Pines analógicos para los transductores
const int TRANS1_PIN = A0;
const int TRANS2_PIN = A1;
const int TRANS3_PIN = A2;
const int TRANS4_PIN = A3;

// ========================================
// CONFIGURACIÓN DE CALIBRACIÓN - ¡AJUSTAR SEGÚN TU TRANSDUCTOR!
// ========================================

// RANGO DEL TRANSDUCTOR EN mm
// Ejemplos comunes:
// - 50mm (0 a 50mm)
// - 100mm (0 a 100mm)  
// - ±25mm (-25 a +25mm) = 50mm total
// - ±50mm (-50 a +50mm) = 100mm total
const float RANGO_TOTAL_MM = 50.0;  // ⚠️ AJUSTAR según tu transductor

// TIPO DE TRANSDUCTOR
// true = Bipolar (±mm), ejemplo: -25 a +25mm
// false = Unipolar (0 a mm), ejemplo: 0 a 50mm
const bool ES_BIPOLAR = false;  // ⚠️ AJUSTAR según tu transductor

// Voltaje de referencia de Arduino
const float V_REF = 5.0;

// Resolución del ADC de Arduino (10 bits = 1024 valores)
const int ADC_RESOLUTION = 1024;

// ========================================
// CALIBRACIÓN MANUAL (Opcional - se puede hacer automática)
// ========================================
// Estos valores se actualizan con la calibración automática
// o puedes medirlos manualmente y ponerlos aquí

int ADC_MIN = 0;      // Valor ADC en posición mínima (se calibra)
int ADC_MAX = 1023;   // Valor ADC en posición máxima (se calibra)
int ADC_ZERO = 512;   // Valor ADC en posición cero/neutra (se calibra)

// ========================================
// FILTRADO Y CONTROL DE LECTURA
// ========================================
const unsigned long INTERVAL = 100; // 100ms = 10 lecturas/segundo
unsigned long previousMillis = 0;

// Filtro de media móvil
const int NUM_SAMPLES = 10;  // 10 muestras para suavizado
int readings[4][NUM_SAMPLES];
int readIndex[4] = {0, 0, 0, 0};
long total[4] = {0, 0, 0, 0};
int average[4] = {0, 0, 0, 0};

// Variables de calibración
bool isCalibrated = false;

void setup() {
  Serial.begin(9600);
  
  // Configurar referencia analógica (usar interna si necesitas más precisión)
  analogReference(DEFAULT); // 5V - cambiar a INTERNAL (1.1V) si necesitas más resolución
  
  // Configurar pines como entrada
  pinMode(TRANS1_PIN, INPUT);
  pinMode(TRANS2_PIN, INPUT);
  pinMode(TRANS3_PIN, INPUT);
  pinMode(TRANS4_PIN, INPUT);
  
  // Inicializar arrays de filtrado
  for(int i = 0; i < 4; i++) {
    for(int j = 0; j < NUM_SAMPLES; j++) {
      readings[i][j] = 0;
    }
  }
  
  // Mensaje de inicio
  Serial.println("========================================");
  Serial.println(" SISTEMA DE MONITOREO DE DEFORMACIONES");
  Serial.println(" Transductores Potenciométricos 2kOhm");
  Serial.println(" Precisión: ±0.005%");
  Serial.println("========================================");
  Serial.println();
  Serial.print("Rango configurado: ");
  if(ES_BIPOLAR) {
    Serial.print("±");
    Serial.print(RANGO_TOTAL_MM / 2.0, 1);
  } else {
    Serial.print("0 a ");
    Serial.print(RANGO_TOTAL_MM, 1);
  }
  Serial.println(" mm");
  Serial.println();
  
  delay(1000);
  
  // CALIBRACIÓN AUTOMÁTICA (comentar si ya calibraste manualmente)
  Serial.println("¿Deseas calibrar? (Envía 'C' en 5 segundos)");
  unsigned long startWait = millis();
  while(millis() - startWait < 5000) {
    if(Serial.available() > 0) {
      char cmd = Serial.read();
      if(cmd == 'C' || cmd == 'c') {
        calibrateTransducers();
        break;
      }
    }
  }
  
  Serial.println();
  Serial.println("Sistema iniciado - Monitoreando deformaciones...");
  Serial.println("========================================");
  Serial.println();
  delay(500);
}

void loop() {
  unsigned long currentMillis = millis();
  
  if (currentMillis - previousMillis >= INTERVAL) {
    previousMillis = currentMillis;
    
    // Leer valores ADC con filtrado
    int adc1 = readFilteredADC(0, TRANS1_PIN);
    int adc2 = readFilteredADC(1, TRANS2_PIN);
    int adc3 = readFilteredADC(2, TRANS3_PIN);
    int adc4 = readFilteredADC(3, TRANS4_PIN);
    
    // Convertir a mm
    float mm1 = adcToMM(adc1);
    float mm2 = adcToMM(adc2);
    float mm3 = adcToMM(adc3);
    float mm4 = adcToMM(adc4);
    
    // Enviar datos en formato para Python (valores ADC 0-1023)
    Serial.print("P1:");
    Serial.print(adc1);
    Serial.print(",P2:");
    Serial.print(adc2);
    Serial.print(",P3:");
    Serial.print(adc3);
    Serial.print(",P4:");
    Serial.println(adc4);
    
    // DESCOMENTAR para ver lecturas en mm en Serial Monitor
    // (útil para debugging y verificación)
    /*
    Serial.print("[mm] T1:");
    Serial.print(mm1, 3);
    Serial.print(" | T2:");
    Serial.print(mm2, 3);
    Serial.print(" | T3:");
    Serial.print(mm3, 3);
    Serial.print(" | T4:");
    Serial.println(mm4, 3);
    */
  }
  
  // Comandos por serial
  if(Serial.available() > 0) {
    char cmd = Serial.read();
    if(cmd == 'C' || cmd == 'c') {
      calibrateTransducers();
    }
  }
}

// ========================================
// LECTURA CON FILTRO DE MEDIA MÓVIL
// ========================================
int readFilteredADC(int transducer, int pin) {
  // Leer nuevo valor
  int newValue = analogRead(pin);
  
  // Restar la lectura antigua
  total[transducer] -= readings[transducer][readIndex[transducer]];
  
  // Guardar nueva lectura
  readings[transducer][readIndex[transducer]] = newValue;
  
  // Sumar nueva lectura
  total[transducer] += newValue;
  
  // Avanzar índice
  readIndex[transducer] = (readIndex[transducer] + 1) % NUM_SAMPLES;
  
  // Calcular y retornar promedio
  average[transducer] = total[transducer] / NUM_SAMPLES;
  return average[transducer];
}

// ========================================
// CONVERSIÓN ADC A MILÍMETROS
// ========================================
float adcToMM(int adcValue) {
  float mm;
  
  if(ES_BIPOLAR) {
    // Transductor bipolar (ejemplo: -25 a +25 mm)
    // ADC_ZERO corresponde a 0mm
    // ADC_MIN corresponde a -RANGO/2
    // ADC_MAX corresponde a +RANGO/2
    
    float halfRange = RANGO_TOTAL_MM / 2.0;
    
    if(adcValue >= ADC_ZERO) {
      // Rango positivo
      float normalized = (float)(adcValue - ADC_ZERO) / (float)(ADC_MAX - ADC_ZERO);
      mm = normalized * halfRange;
    } else {
      // Rango negativo
      float normalized = (float)(ADC_ZERO - adcValue) / (float)(ADC_ZERO - ADC_MIN);
      mm = -normalized * halfRange;
    }
    
  } else {
    // Transductor unipolar (ejemplo: 0 a 50mm)
    // ADC_MIN corresponde a 0mm
    // ADC_MAX corresponde a RANGO_TOTAL_MM
    
    float normalized = (float)(adcValue - ADC_MIN) / (float)(ADC_MAX - ADC_MIN);
    mm = normalized * RANGO_TOTAL_MM;
  }
  
  return mm;
}

// ========================================
// CALIBRACIÓN AUTOMÁTICA
// ========================================
void calibrateTransducers() {
  Serial.println();
  Serial.println("========================================");
  Serial.println("   PROCESO DE CALIBRACIÓN");
  Serial.println("========================================");
  Serial.println();
  
  // Paso 1: Posición MÍNIMA
  Serial.println("PASO 1: Coloca TODOS los transductores en posición MÍNIMA");
  if(ES_BIPOLAR) {
    Serial.print("        (Máxima compresión: -");
    Serial.print(RANGO_TOTAL_MM / 2.0, 1);
    Serial.println(" mm)");
  } else {
    Serial.println("        (Posición inicial: 0 mm)");
  }
  Serial.println("        Presiona ENTER cuando estén listos...");
  waitForEnter();
  
  ADC_MIN = calibratePosition("MÍNIMA");
  Serial.print("✓ Posición mínima calibrada: ADC = ");
  Serial.println(ADC_MIN);
  Serial.println();
  delay(1000);
  
  // Paso 2: Posición MÁXIMA
  Serial.println("PASO 2: Coloca TODOS los transductores en posición MÁXIMA");
  if(ES_BIPOLAR) {
    Serial.print("        (Máxima extensión: +");
    Serial.print(RANGO_TOTAL_MM / 2.0, 1);
    Serial.println(" mm)");
  } else {
    Serial.print("        (Extensión total: ");
    Serial.print(RANGO_TOTAL_MM, 1);
    Serial.println(" mm)");
  }
  Serial.println("        Presiona ENTER cuando estén listos...");
  waitForEnter();
  
  ADC_MAX = calibratePosition("MÁXIMA");
  Serial.print("✓ Posición máxima calibrada: ADC = ");
  Serial.println(ADC_MAX);
  Serial.println();
  delay(1000);
  
  // Paso 3: Posición CERO (solo si es bipolar)
  if(ES_BIPOLAR) {
    Serial.println("PASO 3: Coloca TODOS los transductores en posición NEUTRA");
    Serial.println("        (Sin deformación: 0 mm)");
    Serial.println("        Presiona ENTER cuando estén listos...");
    waitForEnter();
    
    ADC_ZERO = calibratePosition("NEUTRA");
    Serial.print("✓ Posición neutra calibrada: ADC = ");
    Serial.println(ADC_ZERO);
  } else {
    ADC_ZERO = ADC_MIN;  // Para unipolar, zero = min
  }
  
  Serial.println();
  Serial.println("========================================");
  Serial.println("   CALIBRACIÓN COMPLETADA");
  Serial.println("========================================");
  Serial.println("Valores de calibración:");
  Serial.print("  ADC_MIN  = ");
  Serial.println(ADC_MIN);
  Serial.print("  ADC_MAX  = ");
  Serial.println(ADC_MAX);
  Serial.print("  ADC_ZERO = ");
  Serial.println(ADC_ZERO);
  Serial.println();
  Serial.println("Guarda estos valores en el código para");
  Serial.println("no tener que recalibrar cada vez.");
  Serial.println("========================================");
  Serial.println();
  
  isCalibrated = true;
  delay(2000);
}

int calibratePosition(const char* positionName) {
  Serial.print("Tomando ");
  Serial.print(positionName);
  Serial.print(" lecturas");
  
  delay(500);
  
  // Tomar 100 lecturas y promediar
  const int numReadings = 100;
  long sum1 = 0, sum2 = 0, sum3 = 0, sum4 = 0;
  
  for(int i = 0; i < numReadings; i++) {
    sum1 += analogRead(TRANS1_PIN);
    sum2 += analogRead(TRANS2_PIN);
    sum3 += analogRead(TRANS3_PIN);
    sum4 += analogRead(TRANS4_PIN);
    
    if(i % 20 == 0) Serial.print(".");
    delay(20);
  }
  Serial.println();
  
  int avg1 = sum1 / numReadings;
  int avg2 = sum2 / numReadings;
  int avg3 = sum3 / numReadings;
  int avg4 = sum4 / numReadings;
  
  Serial.println("Valores individuales:");
  Serial.print("  T1: "); Serial.println(avg1);
  Serial.print("  T2: "); Serial.println(avg2);
  Serial.print("  T3: "); Serial.println(avg3);
  Serial.print("  T4: "); Serial.println(avg4);
  
  // Retornar promedio de todos
  return (avg1 + avg2 + avg3 + avg4) / 4;
}

void waitForEnter() {
  while(Serial.available() > 0) Serial.read(); // Limpiar buffer
  while(Serial.available() == 0) {
    delay(100);
  }
  while(Serial.available() > 0) Serial.read(); // Limpiar buffer
}

/*
========================================
GUÍA DE USO RÁPIDA
========================================

1. CONFIGURACIÓN INICIAL:
   - Ajustar RANGO_TOTAL_MM (ejemplo: 50.0 para 50mm)
   - Ajustar ES_BIPOLAR (true para ±mm, false para 0-mm)

2. CONEXIÓN DEL HARDWARE:
   Cada transductor potenciométrico:
   - Terminal 1 (inicio) → 5V Arduino
   - Terminal 2 (cursor) → A0, A1, A2, A3
   - Terminal 3 (fin) → GND Arduino

3. CALIBRACIÓN (Primera vez):
   - Abrir Serial Monitor (9600 baud)
   - Enviar letra 'C'
   - Seguir instrucciones en pantalla
   - Anotar valores ADC_MIN, ADC_MAX, ADC_ZERO
   - Ponerlos directamente en el código

4. VERIFICACIÓN:
   - Descomentar las líneas de debug para ver mm
   - Aplicar deformación conocida
   - Verificar que lectura sea correcta

5. TIPOS COMUNES:
   
   Transductor 50mm unipolar (0-50mm):
   - RANGO_TOTAL_MM = 50.0
   - ES_BIPOLAR = false
   
   Transductor 50mm bipolar (±25mm):
   - RANGO_TOTAL_MM = 50.0
   - ES_BIPOLAR = true
   
   Transductor 100mm unipolar (0-100mm):
   - RANGO_TOTAL_MM = 100.0
   - ES_BIPOLAR = false

========================================
ESPECIFICACIONES TÉCNICAS
========================================

Resistencia: 2kΩ ±0.005%
Linealidad: Excelente (potenciométrico)
Resolución Arduino: 10 bits (1024 pasos)
Resolución teórica: RANGO_MM / 1024
  Ejemplo 50mm: 0.049mm por paso
  Ejemplo 100mm: 0.098mm por paso

Para mayor resolución:
- Usar ADC externo 16 bits (ADS1115)
- Reducir ruido con mejor filtrado
- Usar referencia de voltaje estable

========================================
*/